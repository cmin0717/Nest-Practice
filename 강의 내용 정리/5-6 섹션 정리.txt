- Service와 Repository를 따로 분리하는 이유?
서비스에는 비지니스 로직을 수행하는 곳이고 레포지토리는 데이터베이스와 상호작용하는 곳이다.
비지니스 로직에서 레포지토리를 사용하기에 서비스에서 한꺼번에 구현하면 안되는건가?
한번에 구현해도 문제는 없다.
하지만 DB를 바꿔야하거나 비지니스 로직을 바꿔야한다면 서비스 전체를 수정해야한다.
하지만 두가지로 분류해서 처리한다면 한쪽만 수정하면 된다.
또한 두개로 분리해야 독립적인 테스트를 실행하고 유지할수있게 된다.

** 중요 (매우) **
- 의존성 부여를 왜 하나?
nest에서는 각각의 기능을 하는 클래스로 동작한다.
만일 컨트롤러에서 서비스 클래스를 사용한다고 하자
의존성부여 없이 서비스 클래스를 사용한다면 컨트롤러 클래스 안에서 서비스 클래스를 인스턴스화하여 사용해야한다.
하지만 이런 방식이 효과적일까?
매번 사용할때마다 인스턴스화 하는것은 좋지 않고 코드의 재사용성이 떨어지게 된다.
그래서 이런 방식을 해결하고자 나온것이 DI와 IoC이다.

- IoC(Inversion of Control)(제어 역전)이란?
제어 역전이란 프로그램의 주체가 나(개발자)가 아닌 프레임워크에게 주어진 형태이다.
쉽게 말해 내가 사용할 것들을 내가 직접 하는것이 아닌 프레임워크에게 부탁하는것이다.
추상적인 개념이 강한데 나는 이런걸 하면 이런기능이 작동하지만 알고 코딩하는것과 느낌이 비슷하다.
그렇게 하면 프레임워크가 알아서 해당 기능을 수행하는 클래스를 가져와 실행하게 되는것이다.

- DI(Dependency Injection)(의존성 주입)이란?
IoC가 프레임워크가 제어한다라면 DI는 프레임워크가 주체가 되어 너가 필요한 클래스등을 내가 관리할게 같은 느낌이다.
IoC는 추상적인 개념에 가깝기 때문에 해당 개념을 실행하기위해 나온것이 DI이다.
쉽게 말해 IoC에서 말했듯이 프레임워크가 해당 기능을 수행하는 클래스등을 알아서 실행한다고 했다.
그렇게 실행할 클래스등을 관리하기위해 DI방식을 사용하는것이다.

- DI 컨테이너의 작동 방식
nest project를 생성하면 DI 컨테이너를 같이 생성한다.
의존성이 있는 클래스들은 전부 DI컨테이너에 들어간다.
DI컨테이너에는 각 클래스들의 종속성이 표현된다. (ex : 서비스 -> 레포, 컨트롤러 -> 서비스)
컨트롤러에 요청이 들어가서 컨트롤러 클래스를 사용해야 한다면 해당 컨트롤러 클래스의 종속성이 있는 모든 클래스들을 인스턴스화 한다.
인스턴스화한 클래스를 사용하여 컨트롤러의 클래스를 생성한다.
다른곳에서 이미 인스턴스화한 클래스가 필요하다면 다시 인스턴스하지않고 해당 인스턴스를 복제하여 전달하게된다.
DI에 저장된 클래스를 해당 모듈에서 사용하기 위해서는 해당 모듈의 프로바이더로 지정해주어야한다.

- Nest JS에서 DI와 IoC
@Injectable() 데코레이터는 메타 데이터를 첨부하여 해당 클래스가 Nest IoC 컨테이너에서 관리할 수 있는 클래스임을 선언하는것이다.
이렇게 되면 Nest IoC에서 해당 클래스를 싱글톤 패턴으로 관리한다
그러다 해당 클래스가 필요한 클래스가 생기면 클래스 생성자를 통해 해당 클래스에 주입되게 된다.
이렇게 의존성 주입을 통해 사용하려면 Nest 모듈에 Provider로 지정해주어야한다.
또한 DI와 IoC를 사용하면 클래스 간의 결합도를 낮출 수 있다. 
결합도가 낮은 클래스는 서로 독립적으로 개발하고 테스트할 수 있고 이로 인해 코드의 재사용성, 모듈화, 유연성, 테스트 용이성이 향상된다.
각 클래스들은 자기의 역활만 하면된다. 해당 역활을 잘 사용할수있게 우리가 잘 코드하는것이 DI와 IoC를 사용한 방법이다