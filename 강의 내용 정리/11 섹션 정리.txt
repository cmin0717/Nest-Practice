- PassWord의 암호화 저장
일반적으로 DB에 사용자 정보를 저장할때 password는 있는 그대로 저장하는것이 아닌 암호화해서 저장해야한다.
암호화에는 여러 방법이 있지만 가장 대표적으로 해쉬함수를 사용한 암호화가있다.

- 암호화해서 저장하는것만으로 괜찬은가?
해쉬함수를 통해 암호화할 경우에는 항상 같은 값은 같은 해쉬값을 리턴한다.
그렇기에 방대한 양으로 자주 사용하는 비밀번호를가지고 여러번 확인하다보면 결국 해당 해쉬값이 어떤 값으로 만들어졌는지 찾을수있다.
이런 공격을 레인보우 어택이라고 한다.

- 레인보우어택을 방지하기 위한 방법
해쉬과정에 salt라는 특정값을 넣어 실제 password해쉬값과 다르게 저장하는 것이다.
password + salt -> 해쉬 함수 -> 해쉬 값
해쉬 값 + salt값을 데이터 베이스에 저장한다.
그러면 인증할때는 주어진 email값으로 데이터 베이스의 해쉬값을 가져오고 거기서 salt값을 구해온다.
구해온 salt값과 입력한 password를 합쳐 해쉬과정을 통해 데이터 베이스와 같으면 같은 비밀번호인것이다.
이런식으로 암호화를 진행하게 되면 레이보우 어택도 경우의수가 너무 많아지기에 사실상 불가능해지는것이다.
salt값은 항상 다른 값으로 임의로 가져와 부여한다.

- Crypto vs Bcrypt
Bcrypt는 Blowfish 알고리즘을 사용하기 때문에 해싱에 엄청난 비용이 든다고 한다. 
만약 해커가 브루트 포스같은 공격을 해대면 뚫리지는 않을지라도 서버에 엄청난 부하가 가해진다.
그렇기에 Crypto와 salt를 사용하여 암호화 한다면 효율적이라고 생각한다.
사실 정보가 많이 없어 부정확한 정보일수도있다.
하지만 확실한것은 Crypto는 node js의 내장 라이브러리이다.
외장보다는 내장 라이브러리가 훨씬 안전하다.

- 커스텀 데코레이터에서 의존성부여가 필요한 작업을 진행할경우
만일 세션에 아이디를 저장하여 현재 유저 정보를 가져오는 커스텀 데코레이터를 만든다고 하자
커스텀 데코레이터는 클래스가 아니기에 의존성 부여를 할수가없다. 그럼 아이디를 가져와도 DB에 접근할 서비스를 가져오지 못하는것이다.
그럼 어떻게 해야할까?
인터셉터를 사용하는것이다.
인터셉터를 사용하여 데코레이터를 실행하기전에 req객체에 user정보를 넣어주는것이다.
이렇게 되면 커스텀 데코레이터에서는 req에서 유저 정보를 보내주기만한다면 의존성 부여 없이 데코레이터를 구현할수있게된다.

- jwt인증 방법은 항상 Strategy를 사용해야 하는가?
아니다.
인터셉터를 이용하여 jwt인증을 진행할수있다.
인터셉터로 인증을 검증할경우 Strategy보다 유연성있게 작업을 진행할수있다.
하지만 Strategy보다 구현하기가 복작해지고 성능이 저하될수있기에 각 상황에 맞게 진행하는것이 좋을듯 하다.